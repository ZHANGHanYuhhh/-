# LeetCode 15-25,
### 15.三数之和

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

<table><td>
示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

</td></table>
分析：这题难点在于不能使用暴力解法，会超时。这类题要先进行排序，使用c++自带的soft函数，让整个数组从小到大排列，然后使用三个伪指针进行遍历。

为了优化算法，我做了以下几个工作：首先重新生成vector数组，将除了零之外所有的存在三个相同以及上的数字替换为两个，因为只有0+0+0 = 0,其次，将最小的两个数和最大的数相加，如果结果大于零则移动最大的数，将最大的两个数和最小的数相加，如果结果小于零则移动最小的数，通过调整后进一步缩小范围。之后使用嵌套while循环来进行判断。注意要除重，这个除重中无法使用unique和erase的组合（因为无法做到数组的排序，会产生（2,0,2），（2,1,2），（2,0,2）类似的组合）

时间复杂度O（n^2）,空间复杂度O（n）。

### 16.最接近的三数之和

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

<table><td>
  
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

</td></table>

分析：这题与上面的题十分类似，只需要记录下绝对值最小的三个数和即可，并无难度。
时间复杂度O(n^2),空间复杂度O(1)。

### 17.电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![Image text](https://github.com/ZHANGHanYuhhh/-/blob/master/Image/17.png)

<table><td>
示例:

输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

</td></table>
说明:
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

分析：我使用递归的方法来求解该题。每次取下字符串最开头的字符，剩下的字符串递归下去，最后将返回的vector数组与字符对应的字母所连接，最后再存入vector数组。这题在LeetCode上提交时，不知道为什么会运行报错，而在本地运行没有问题，原先的写法是单写一个函数，返回的是vector<vector<char>>数组，目的是保存数字与字母之间的对应关系，但是由于报错只能每次递归时都要进行重新声明以及赋值，使得内存开销变大。
  
时间复杂度O(N), 空间复杂度O(M)。

### 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

<table><td>
示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</td></table>
分析：这题我直接用的暴力解法，其实可以直接三数之和的解法直接套个循环，但是懒得做了，没想到还过了……先排序，再求第四个值target-(a+b+c)是否存在。

时间复杂度O(n^4),空间复杂度O(1)。


### 19.删除链表的倒数第N个节点

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

<table><td>
示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.

</td></table>
说明：

给定的 n 保证是有效的。

进阶：

你能尝试使用一趟扫描实现吗？

分析：

这个题感觉上并不难，要实现一遍扫描就找到节点位置，可以用两个节点，一个节点遍历，另一个来找出倒数第n个节点的位置，当遍历的节点向后移动了n位后，该节点开始一同后移，（要让target节点始终指向倒数第n位节点的前一个节点或者倒数第n位节点）直到遍历节点到尾部，此时进行处理。

时间复杂度 O(n），空间复杂度O(1）。

### 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

1.左括号必须用相同类型的右括号闭合。

2.左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

<table><td>
示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true


</td></table>

分析： 这个题让我想起了本科做的简易计算器，直接用栈就行了，注意空栈的情况。

时间复杂度O(n), 空间复杂度O(m)。

### 21. 合并两个有序链表

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

<table><td>
示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
</td></table>

分析：简单的合并链表操作，将较小的节点连接在一个新链表上，注意判断空表和一长一短的链表即可。

时间复杂度O(n)，也即遍历最长的那一个链表的时间（理论上应该是m+n,但是近似于2n，指数倍省略就是n），空间复杂度O(m+n)。

### 22. 括号生成

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：

<table><td>
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
</td></table>

分析：这题就比较难了，难点并不是在于数出有多少种括号，在于如何去写出代码，因为输入的n不同，不能多个指针通过移动来判断，只能通过不断的改变字符串，然后判断是否合理。这题的关键在于如何找到规律，下面是我的实现思路（以n为4为例）：

初始化为(((())))，最终结果偶数位都为(,即()()()()，每次只移动最后一个(，移动到倒数第二位时，重新生成字符串,生成方法为，从最后一位(开始向前遍历，并且记录遇到的(),遇到)计数器加1，遇到(减1，如果遇到（时计数器为0则继续向前，即如这种情况(())()()，倒数第二个(的计数器的值为0，表示无法移动该位，继续向前，直到找到一个(，在该位的计数器值大于0；此时将该位前字符串不动，该位替换为），并且按照之前剩余（）数，生成新字符串，上述字符串生成为：()((()))，之后继续移动最后一位的（,直到达到最终状态。

时间复杂度O(n^2),空间复杂度O(1)。

### 23. 合并K个排序链表

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

<table><td>
示例:

输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6

</td></table>

分析：此题并不难，主要思路是每次从vector数组中找到最小的节点，取出，存入新的链表中，然后把该节点后移，之后把此链表存入原先的vector数组，直至vector数组为空为止，要注意是删除vector数组指定位置元素的方法（用iterator迭代器，配合erase函数，要注意erase后，所去除元素位置后的所有元素会依次向前移动一位。）

时间复杂度O(n^2), 空间复杂度O(m)。

### 24. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

<table><td>
示例:

给定 1->2->3->4, 你应该返回 2->1->4->3.
</td></table>
分析：首先判断特殊情况，即链表中只有一个或者没有节点的时候，直接返回。接着使用双指针遍历，进行节点交换即可，注意不要断链即可（先交换完头两个节点，之后使用一个指针始终指向要交换的两个节点的前面一个节点，用来防止断链）。

时间复杂度O(n)，空间复杂度O(1)。

### 25. K个一组翻转链表

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

示例 :

给定这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5

说明 :

你的算法只能使用常数的额外空间。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

分析：这题其实并不难，思路在于如何找到交换规律，首先我是使用三个指针，首先判断剩余的链表长度是否需要交换，要是需要交换：一个指向要交换的节点，一个指向要交换的链表的尾部，一个指向要交换的链表头部的前一个节点，然后每次移动一位进行交换。注意判断第一次交换和之后的交换即可。

时间复杂度O(n)，空间复杂度O(1)。

